crystal_doc_search_index_callback({"repository_name":"json-serializable-fake","body":"<div align=\"center\">\n  <a href=\"https://github.com/ryan-kraay/json-serializable-fake/\" target=\"_blank\" rel=\"noopener noreferrer\">\n    <img width=\"300\" src=\"https://raw.githubusercontent.com/ryan-kraay/json-serializable-fake/master/assets/logo.png\" alt=\"Logo\">\n  </a>\n  \n  <h1>Use JSON::Serializable to generate dynamic JSON/fields</h1>\n  \n  <p>\n    <a href=\"https://github.com/ryan-kraay/json-serializable-fake/actions/workflows/ci.yml\">\n      <img src=\"https://github.com/ryan-kraay/json-serializable-fake/actions/workflows/ci.yml/badge.svg\" alt=\"Build Status\">\n    </a>\n    <a href=\"https://github.com/ryan-kraay/json-serializable-fake/blob/main/LICENSE\">\n      <img src=\"https://img.shields.io/github/license/ryan-kraay/json-serializable-fake.svg\" alt=\"License\">\n    </a>\n    <a href=\"https://ryan-kraay.github.io/json-serializable-fake/index.html\">\n      <img src=\"https://img.shields.io/badge/documentation-API-f06\" alt=\"API Documentation\">\n    </a>\n    <a href=\"https://github.com/ryan-kraay/json-serializable-fake/releases\">\n      <img src=\"https://img.shields.io/github/release/ryan-kraay/json-serializable-fake.svg\" alt=\"GitHub release\">\n    </a>\n  </p>\n\n  <h3>\n    <a href=\"https://github.com/ryan-kraay/json-serializable-fake/\">Website</a>\n    <span> â€¢ </span>\n    <a href=\"https://ryan-kraay.github.io/json-serializable-fake/index.html\">Shard Docs</a>\n  </h3>\n</div>\n\n<hr/>\n\n\nA Crystal Library which extends JSON::Serializable to allow JSON to be generated via method calls, instead of _requiring_ the use of variables.\n\n**NOTE**:  This library _only_ supports **Serialization**.  **Deserialization** to _Fake FIelds_ is not possible.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     serializable-fake:\n       github: ryan-kraay/json-serializable-fake\n   ```\n\n2. Run `shards install`\n\n## Usage\n\n```crystal\nrequire \"json\"\nrequire \"json-serializable-fake\"\n\nclass Sum\n  include JSON::Serializable\n  include JSON::Serializable::Fake\n\n  property a : UInt32\n  property b : UInt32\n\n  def initialize(@a, @b)\n  end\n\n  @[JSON::FakeField]\n  def sum(json : ::JSON::Builder) : Nil\n    json.number(a + b)\n  end\nend\n\ns = Sum.new(10, 5)\nputs s.to_json    # => { \"a\": 10, \"b\": 5, \"sum\": 15 }\n```\n\nAdditional documentation can be found [here](https://ryan-kraay.github.io/json-serializable-fake/JSON/Serializable/Fake.html).\n\n## Features\n\nThis library was born out of desire to use classes and members to construct JSON object, but **also** to use methods to construct JSON fields that _do not necessarily need to be stored as members in a class definition_.\n\nSome additional features:\n* `JSON::FakeField(key: <name>)`:  creates a field with an explicit name (by default it uses the method name)\n* `JSON::FakeField(supress_key: true)`:  if `true` no json field will be implicitly added.  This allows the method to create multiple json fields or an entire JSON document using `JSON::Builder`.\n* Integrates with `JSON::Serializable` and `JSON::Serializable::Unmapped`:  this allows you to mix-and-match and create nested `JSON::Serializable` and `JSON::Serializable::Fake` objects.\n* It is possible to change, manipulate, or remove `JSON::Serializable` fields _at runtime_.\n\n**NOTE**:  The use of `JSON::Serializable` relies on an \"opt-out\" feature (ie: `JSON::Field(ignore_serialization: true)]`).  Meaning _all_ instance variables will be added to the json document, _unless you explicitly \"opt-out\"._.  `JSON::Serializable::Fake` relies on an \"opt-in\" for instance methods.  Meaning that _only_ those instance methods which contain the `JSON::FakeField` annotation will be added to the json document.\n\n## Advanced Example\n\n```crystal\nrequire \"json\"\nrequire \"json-serializable-fake\"\n\nclass User\n  include JSON::Serializable\n  include JSON::Serializable::Fake\n\n  property first : String\n  property last : String\n  property password : String\n\n  @[JSON::FakeField]\n  def user(json : ::JSON::Builder) : Nil\n    json.string( (@first + @last).downcase )\n  end\n\n  def initialize(@first, @last, @password)\n  end\nend\n\nclass SecuredUser < User\n  property age : UInt32\n\n  # replace our user() implementation via simple inheritance\n  def user(json : ::JSON::Builder) : Nil\n    json.string(\"retracted\")\n  end\n\n  @[JSON::FakeField(key: password)]\n  def hide_password(json : ::JSON::Builder) : Nil\n    json.string(\"******\")\n  end\n\n  @[JSON::FakeField(suppress_key: true)]\n  def age(json : ::JSON::Builder) : Nil\n    # Only show the age, if the user is over 18\n    if age > 18\n      json.field \"age\", @age\n    end\n  end\n\n  def initialize(@first, @last, @age, @password)\n  end\nend\n\nuser = User.new(\"John\", \"Doe\", \"hunter2\")\nputs user.to_json     # => {\"first\":\"John\",\"last\":\"Doe\",\"password\":\"hunter2\",\"user\":\"johndoe\"}\n\nchild = SecuredUser.new(\"Jimmy\", \"Doe\", 5_u32, \"hunter2\")\nputs child.to_json    # => {\"first\":\"Jimmy\",\"last\":\"Doe\",\"password\":\"******\",\"user\":\"retracted\"}\nputs child.password   # => hunter2\n\nadult = SecuredUser.new(\"Jane\", \"Doe\", 24_u32, \"hunter2\")\nputs adult.to_json    # => {\"first\":\"Jane\",\"last\":\"Doe\",\"password\":\"******\",\"age\":24,\"user\":\"retracted\"}\nputs adult.password   # => hunter2\n\n```\n\n## Limitations\n\n1. This library only supports JSON _Serialization_ (not YAML).  There is no technical reason for this limitation, just a lack of time.\n2. This library only support _Serialization_.  _Deserializing_ into a method call is not support.  Again, there is no technical limitation, only time.  However, `JSON::FakeFields` will appear as `objecct.json_unmapped[<fakefield>]`, when `JSON::Serializable::Unmapped` is used.\n\n## Contributing\n\n1. Fork it (<https://github.com/ryan-kraay/json-serializable-fake/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n","program":{"html_id":"json-serializable-fake/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"locations":[],"repository_name":"json-serializable-fake","program":true,"enum":false,"alias":false,"const":false,"types":[{"html_id":"json-serializable-fake/JSON","path":"JSON.html","kind":"module","full_name":"JSON","name":"JSON","abstract":false,"locations":[{"filename":"src/json-serializable-fake.cr","line_number":10,"url":"https://github.com/ryan-kraay/json-serializable-fake/blob/4d5f13fc41af780ac50191802b0e82664a93e642/src/json-serializable-fake.cr#L10"}],"repository_name":"json-serializable-fake","program":false,"enum":false,"alias":false,"const":false,"doc":"The JSON module allows parsing and generating [JSON](http://json.org/) documents.\n\nNOTE: To use `JSON` or its children, you must explicitly import it with `require \"json\"`\n\n### General type-safe interface\n\nThe general type-safe interface for parsing JSON is to invoke `T.from_json` on a\ntarget type `T` and pass either a `String` or `IO` as an argument.\n\n```\nrequire \"json\"\n\njson_text = %([1, 2, 3])\nArray(Int32).from_json(json_text) # => [1, 2, 3]\n\njson_text = %({\"x\": 1, \"y\": 2})\nHash(String, Int32).from_json(json_text) # => {\"x\" => 1, \"y\" => 2}\n```\n\nSerializing is achieved by invoking `to_json`, which returns a `String`, or\n`to_json(io : IO)`, which will stream the JSON to an `IO`.\n\n```\nrequire \"json\"\n\n[1, 2, 3].to_json            # => \"[1,2,3]\"\n{\"x\" => 1, \"y\" => 2}.to_json # => \"{\\\"x\\\":1,\\\"y\\\":2}\"\n```\n\nMost types in the standard library implement these methods. For user-defined types\nyou can define a `self.new(pull : JSON::PullParser)` for parsing and\n`to_json(builder : JSON::Builder)` for serializing. The following sections\nshow convenient ways to do this using `JSON::Serializable`.\n\nNOTE: JSON object keys are always strings but they can still be parsed\nand deserialized to other types. To deserialize, define a\n`T.from_json_object_key?(key : String) : T?` method, which can return `nil`\nif the string can't be parsed into that type. To serialize, define a\n`to_json_object_key : String` method can be serialized that way.\nAll integer and float types in the standard library can be deserialized that way.\n\n```\nrequire \"json\"\n\njson_text = %({\"1\": 2, \"3\": 4})\nHash(Int32, Int32).from_json(json_text) # => {1 => 2, 3 => 4}\n\n{1.5 => 2}.to_json # => \"{\\\"1.5\\\":2}\"\n```\n\n### Parsing with `JSON.parse`\n\n`JSON.parse` will return an `Any`, which is a convenient wrapper around all possible JSON types,\nmaking it easy to traverse a complex JSON structure but requires some casts from time to time,\nmostly via some method invocations.\n\n```\nrequire \"json\"\n\nvalue = JSON.parse(\"[1, 2, 3]\") # : JSON::Any\n\nvalue[0]               # => 1\ntypeof(value[0])       # => JSON::Any\nvalue[0].as_i          # => 1\ntypeof(value[0].as_i)  # => Int32\nvalue[0].as_i?         # => 1\ntypeof(value[0].as_i?) # => Int32 | Nil\nvalue[0].as_s?         # => nil\ntypeof(value[0].as_s?) # => String | Nil\n\nvalue[0] + 1       # Error, because value[0] is JSON::Any\nvalue[0].as_i + 10 # => 11\n```\n\n`JSON.parse` can read from an `IO` directly (such as a file) which saves\nallocating a string:\n\n```\nrequire \"json\"\n\njson = File.open(\"path/to/file.json\") do |file|\n  JSON.parse(file)\nend\n```\n\nParsing with `JSON.parse` is useful for dealing with a dynamic JSON structure.\n\n### Generating with `JSON.build`\n\nUse `JSON.build`, which uses `JSON::Builder`, to generate JSON\nby emitting scalars, arrays and objects:\n\n```\nrequire \"json\"\n\nstring = JSON.build do |json|\n  json.object do\n    json.field \"name\", \"foo\"\n    json.field \"values\" do\n      json.array do\n        json.number 1\n        json.number 2\n        json.number 3\n      end\n    end\n  end\nend\nstring # => %<{\"name\":\"foo\",\"values\":[1,2,3]}>\n```\n\n### Generating with `to_json`\n\n`to_json`, `to_json(IO)` and `to_json(JSON::Builder)` methods are provided\nfor primitive types, but you need to define `to_json(JSON::Builder)`\nfor custom objects, either manually or using `JSON::Serializable`.","summary":"<p>The JSON module allows parsing and generating <a href=\"http://json.org/\">JSON</a> documents.</p>","types":[{"html_id":"json-serializable-fake/JSON/Serializable","path":"JSON/Serializable.html","kind":"module","full_name":"JSON::Serializable","name":"Serializable","abstract":false,"locations":[{"filename":"src/json-serializable-fake.cr","line_number":7,"url":"https://github.com/ryan-kraay/json-serializable-fake/blob/4d5f13fc41af780ac50191802b0e82664a93e642/src/json-serializable-fake.cr#L7"}],"repository_name":"json-serializable-fake","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"json-serializable-fake/JSON","kind":"module","full_name":"JSON","name":"JSON"},"doc":"The `JSON::Serializable` module automatically generates methods for JSON serialization when included.\n\n### Example\n\n```\nrequire \"json\"\n\nclass Location\n  include JSON::Serializable\n\n  @[JSON::Field(key: \"lat\")]\n  property latitude : Float64\n\n  @[JSON::Field(key: \"lng\")]\n  property longitude : Float64\nend\n\nclass House\n  include JSON::Serializable\n  property address : String\n  property location : Location?\nend\n\nhouse = House.from_json(%({\"address\": \"Crystal Road 1234\", \"location\": {\"lat\": 12.3, \"lng\": 34.5}}))\nhouse.address  # => \"Crystal Road 1234\"\nhouse.location # => #<Location:0x10cd93d80 @latitude=12.3, @longitude=34.5>\nhouse.to_json  # => %({\"address\":\"Crystal Road 1234\",\"location\":{\"lat\":12.3,\"lng\":34.5}})\n\nhouses = Array(House).from_json(%([{\"address\": \"Crystal Road 1234\", \"location\": {\"lat\": 12.3, \"lng\": 34.5}}]))\nhouses.size    # => 1\nhouses.to_json # => %([{\"address\":\"Crystal Road 1234\",\"location\":{\"lat\":12.3,\"lng\":34.5}}])\n```\n\n### Usage\n\nIncluding `JSON::Serializable` will create `#to_json` and `self.from_json` methods on the current class,\nand a constructor which takes a `JSON::PullParser`. By default, these methods serialize into a json\nobject containing the value of every instance variable, the keys being the instance variable name.\nMost primitives and collections supported as instance variable values (string, integer, array, hash, etc.),\nalong with objects which define to_json and a constructor taking a `JSON::PullParser`.\nUnion types are also supported, including unions with nil. If multiple types in a union parse correctly,\nit is undefined which one will be chosen.\n\nTo change how individual instance variables are parsed and serialized, the annotation `JSON::Field`\ncan be placed on the instance variable. Annotating property, getter and setter macros is also allowed.\n```\nrequire \"json\"\n\nclass A\n  include JSON::Serializable\n\n  @[JSON::Field(key: \"my_key\", emit_null: true)]\n  getter a : Int32?\nend\n```\n\n`JSON::Field` properties:\n* **ignore**: if `true` skip this field in serialization and deserialization (by default false)\n* **ignore_serialize**: If truthy, skip this field in serialization (default: `false`). The value can be any Crystal expression and is evaluated at runtime.\n* **ignore_deserialize**: if `true` skip this field in deserialization (by default false)\n* **key**: the value of the key in the json object (by default the name of the instance variable)\n* **root**: assume the value is inside a JSON object with a given key (see `Object.from_json(string_or_io, root)`)\n* **converter**: specify an alternate type for parsing and generation. The converter must define `from_json(JSON::PullParser)` and `to_json(value, JSON::Builder)`. Examples of converters are a `Time::Format` instance and `Time::EpochConverter` for `Time`.\n* **presence**: if `true`, a `@{{key}}_present` instance variable will be generated when the key was present (even if it has a `null` value), `false` by default\n* **emit_null**: if `true`, emits a `null` value for nilable property (by default nulls are not emitted)\n\nDeserialization also respects default values of variables:\n```\nrequire \"json\"\n\nstruct A\n  include JSON::Serializable\n  @a : Int32\n  @b : Float64 = 1.0\nend\n\nA.from_json(%<{\"a\":1}>) # => A(@a=1, @b=1.0)\n```\n\n### Extensions: `JSON::Serializable::Strict` and `JSON::Serializable::Unmapped`.\n\nIf the `JSON::Serializable::Strict` module is included, unknown properties in the JSON\ndocument will raise a parse exception. By default the unknown properties\nare silently ignored.\nIf the `JSON::Serializable::Unmapped` module is included, unknown properties in the JSON\ndocument will be stored in a `Hash(String, JSON::Any)`. On serialization, any keys inside json_unmapped\nwill be serialized and appended to the current json object.\n```\nrequire \"json\"\n\nstruct A\n  include JSON::Serializable\n  include JSON::Serializable::Unmapped\n  @a : Int32\nend\n\na = A.from_json(%({\"a\":1,\"b\":2})) # => A(@json_unmapped={\"b\" => 2}, @a=1)\na.json_unmapped[\"b\"].raw.class    # => Int64\na.to_json                         # => %({\"a\":1,\"b\":2})\n```\n\n\n### Class annotation `JSON::Serializable::Options`\n\nsupported properties:\n* **emit_nulls**: if `true`, emits a `null` value for all nilable properties (by default nulls are not emitted)\n\n```\nrequire \"json\"\n\n@[JSON::Serializable::Options(emit_nulls: true)]\nclass A\n  include JSON::Serializable\n  @a : Int32?\nend\n```\n\n### Discriminator field\n\nA very common JSON serialization strategy for handling different objects\nunder a same hierarchy is to use a discriminator field. For example in\n[GeoJSON](https://tools.ietf.org/html/rfc7946) each object has a \"type\"\nfield, and the rest of the fields, and their meaning, depend on its value.\n\nYou can use `JSON::Serializable.use_json_discriminator` for this use case.\n\n### `after_initialize` method\n\n`#after_initialize` is a method that runs after an instance is deserialized\nfrom JSON. It can be used as a hook to post-process the initialized object.\n\nExample:\n```\nrequire \"json\"\n\nclass Person\n  include JSON::Serializable\n  getter name : String\n\n  def after_initialize\n    @name = @name.upcase\n  end\nend\n\nperson = Person.from_json %({\"name\": \"Jane\"})\nperson.name # => \"JANE\"\n```","summary":"<p>The <code><a href=\"../JSON/Serializable.html\">JSON::Serializable</a></code> module automatically generates methods for JSON serialization when included.</p>","types":[{"html_id":"json-serializable-fake/JSON/Serializable/Fake","path":"JSON/Serializable/Fake.html","kind":"module","full_name":"JSON::Serializable::Fake","name":"Fake","abstract":false,"locations":[{"filename":"src/json-serializable-fake.cr","line_number":3,"url":"https://github.com/ryan-kraay/json-serializable-fake/blob/4d5f13fc41af780ac50191802b0e82664a93e642/src/json-serializable-fake.cr#L3"},{"filename":"src/json-serializable-fake.cr","line_number":61,"url":"https://github.com/ryan-kraay/json-serializable-fake/blob/4d5f13fc41af780ac50191802b0e82664a93e642/src/json-serializable-fake.cr#L61"}],"repository_name":"json-serializable-fake","program":false,"enum":false,"alias":false,"const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.0.1\""}],"namespace":{"html_id":"json-serializable-fake/JSON/Serializable","kind":"module","full_name":"JSON::Serializable","name":"Serializable"},"doc":"`JSON::Serializable::Fake` allows method calls to generate JSON content.\n\n### Example\n\n```\nrequire \"json/fakefield\"\n\nclass Sum\n  include JSON::Serializable\n  include JSON::Serializable::Fake\n\n  property a : UInt32\n  property b : UInt32\n\n  def initialize(@a, @b)\n  end\n\n  @[JSON::FakeField]\n  def sum(json : ::JSON::Builder) : Nil\n    json.number(a + b)\n  end\nend\n\ns = Sum.new(10, 5)\nputs s.to_json # => { \"a\": 10, \"b\": 5, \"sum\": 15 }\n```\n\n### Usage\n\n`JSON::Serializable::Fake` will create `extend_to_json` (which will actually call\nyour methods) and will replace the `on_to_json` method generated by `JSON::Serializable`.\n\n`JSON::Serializable::Fake` **is** compatible with `JSON::Serializable::Unmapped` and\n`JSON::Serializable::Strict` _as long as_ `JSON::Serializable::Fake` is included **last**.\n\nYou can customize the behavior of each fake field via the `JSON::FakeField` annotation.\nMethod calls **MUST** accept `::JSON::Builder` as a parameter and return `::Nil`.  The\nconstruction of JSON elements is handled via [::JSON::Builder](https://github.com/crystal-lang/crystal/blob/master/src/json/builder.cr#L6).\n\n`JSON::FakeField` properties:\n* **key**: an explicit name of the field added to the json string (by default it uses the method name)\n* **suppress_key**: if `true` no json field will be implictly added.  This allows the method call to create multiple json fields\n\nWARNING: At the moment it is **not** possible to deserialize fake fields into a method call.  There is no technical limitation,\njust a lack of time.  However, you can use `JSON::Serializable::Unmapped` to capture all the fake fields.\n","summary":"<p><code><a href=\"../../JSON/Serializable/Fake.html\">JSON::Serializable::Fake</a></code> allows method calls to generate JSON content.</p>","instance_methods":[{"html_id":"to_json(json:JSON::Builder)-instance-method","name":"to_json","doc":"heavily modelled after:\nhttps://github.com/crystal-lang/crystal/blob/fda656c71/src/json/serialization.cr#L181","summary":"<p>heavily modelled after: https://github.com/crystal-lang/crystal/blob/fda656c71/src/json/serialization.cr#L181</p>","abstract":false,"args":[{"name":"json","external_name":"json","restriction":"::JSON::Builder"}],"args_string":"(json : JSON::Builder)","args_html":"(json : JSON::Builder)","location":{"filename":"src/json-serializable-fake.cr","line_number":64,"url":"https://github.com/ryan-kraay/json-serializable-fake/blob/4d5f13fc41af780ac50191802b0e82664a93e642/src/json-serializable-fake.cr#L64"},"def":{"name":"to_json","args":[{"name":"json","external_name":"json","restriction":"::JSON::Builder"}],"visibility":"Public","body":"{% if true %}\n        {% options = @type.annotation(::JSON::Serializable::Options) %}\n        {% emit_nulls = options && options[:emit_nulls] %}\n\n        {% properties = {} of Nil => Nil %}\n        {% for ivar in @type.instance_vars %}\n          {% ann = ivar.annotation(::JSON::Field)\nkey = ((ann && ann[:key]) || ivar).id\n %}\n          {% if ann && (ann[:ignore] || (ann[:ignore_serialize] == true)) %}{% else %}\n            {% properties[key] = {key: key.stringify, root: ann && ann[:root], converter: ann && ann[:converter], emit_null: (ann && (ann[:emit_null] != nil) ? ann[:emit_null] : emit_nulls), ignore_serialize: ann && ann[:ignore_serialize], ivar: ivar.id, imeth: nil, suppress_key: nil} %}\n          {% end %}\n        {% end %}\n\n        {% for t in (@type.ancestors + [@type]) %}\n          {% for imeth in t.methods %}\n            {% ann = imeth.annotation(::JSON::FakeField) %}\n            {% if ann && (!(ann[:ignore] || (ann[:ignore_serialize] == true))) %}\n              {% key = ((ann && ann[:key]) || imeth.name).id\nproperties[key] = {key: key.stringify, root: nil, converter: nil, emit_null: nil, ignore_serialize: nil, ivar: nil, imeth: imeth.name, suppress_key: (ann && ann[:suppress_key])}\n %}\n            {% end %}\n          {% end %}\n        {% end %}\n\n        json.object do\n          {% for name, value in properties %}\n            {% if value[:imeth] %}\n              {% if value[:suppress_key] %}\n                {{ value[:imeth] }} json\n              {% else %}\n                json.field {{ value[:key] }} do\n                  {{ value[:imeth] }} json\n                end\n              {% end %}\n            {% else %}\n              {% name = value[:ivar] %}\n              _{{ name }} = @{{ name }}\n\n              {% if value[:ignore_serialize] %}\n                unless {{ value[:ignore_serialize] }}\n              {% end %}\n\n                {% if value[:emit_null] %}{% else %}\n                  unless _{{ name }}.nil?\n                {% end %}\n\n                  json.field({{ value[:key] }}) do\n                    {% if value[:root] %}\n                      {% if value[:emit_null] %}\n                        if _{{ name }}.nil?\n                          nil.to_json(json)\n                        else\n                      {% end %}\n\n                      json.object do\n                        json.field({{ value[:root] }}) do\n                    {% end %}\n\n                    {% if value[:converter] %}\n                      if _{{ name }}\n                        {{ value[:converter] }}.to_json(_{{ name }}, json)\n                      else\n                        nil.to_json(json)\n                      end\n                    {% else %}\n                      _{{ name }}.to_json(json)\n                    {% end %}\n\n                    {% if value[:root] %}\n                      {% if value[:emit_null] %}\n                        end\n                      {% end %}\n                        end\n                      end\n                    {% end %}\n                  end\n\n                {% if value[:emit_null] %}{% else %}\n                  end\n                {% end %}\n              {% if value[:ignore_serialize] %}\n                end\n              {% end %}\n            {% end %}\n          {% end %}\n          on_to_json(json)\n        end\n      {% end %}"}}]}]}]}]}})